# Commitment Project Constitution

This document defines the core principles and standards that govern all development in the commitment project. These principles are non-negotiable and must be upheld in all code, features, and decisions.

## 1. Code Quality Principles

### 1.1 Type Safety First
- **All code must be strictly typed** with TypeScript's strictest settings enabled
- **No `any` types** in production code except in test mocks where absolutely necessary (with eslint-disable comments)
- **Explicit return types** required for all public functions and methods
- **Discriminated unions** preferred over loose object types for complex data structures
- **Zod schemas** required for all external data validation (user input, API responses, config files)

### 1.2 Functional Patterns
- **Pattern matching with ts-pattern** required for complex conditional logic (no switch statements or long if/else chains)
- **Pure functions** preferred wherever possible - avoid mutations and side effects
- **Immutability** enforced using `as const`, `readonly`, and immutable data structures
- **Guard functions** required for type narrowing - use utilities from `utils/guards.ts` instead of inline checks
- **No null assertions (`!`)** - use type guards and optional chaining instead

### 1.3 Code Organization
- **Named exports only** - no default exports except in config files
- **Extensionless imports** - never specify file extensions in import statements
- **Import ordering enforced**:
  1. Node.js built-ins (with `node:` protocol)
  2. External dependencies
  3. Internal imports
- **Co-located tests** - unit and integration tests live in `__tests__/` folders next to the code they test
- **Barrel exports** - use index.ts files to provide clean public APIs

### 1.4 Error Handling
- **Custom error classes** for domain-specific errors with proper inheritance
- **Type guards** for error identification (`isProviderError()`, `isProviderChainError()`)
- **Error formatting utilities** for user-friendly error messages
- **Never swallow errors** - always handle or propagate with context

## 2. Testing Standards

### 2.1 Test Coverage Requirements
- **All new features require tests** before code review
- **Critical business logic** must have >90% code coverage
- **Public APIs** must have comprehensive test coverage
- **Error paths** must be tested as thoroughly as happy paths

### 2.2 Test Organization
Four distinct test types with clear separation:

1. **Unit Tests** (`*.test.ts`):
   - Heavy mocking of external dependencies
   - Fast execution (< 5s timeout)
   - Test business logic in isolation
   - Co-located in `src/**/__tests__/`

2. **Integration Tests** (`*.integration.test.ts`):
   - Real class interactions
   - Mock only external I/O (file system, network, git)
   - Medium execution (< 10s timeout)
   - Co-located in `src/**/__tests__/`

3. **E2E Tests** (`test/e2e/*.test.ts`):
   - Complete CLI workflows
   - Real file system operations (isolated)
   - Long execution (< 30s timeout)
   - Validates user-facing behavior

4. **Execution Planning Tests** (`test/execution/*.test.ts`):
   - Uses Claude API for plan validation
   - Very long execution (< 60s timeout)
   - Cost-efficient quality analysis

### 2.3 Test Quality Standards
- **Clear test names** that describe behavior, not implementation
- **Arrange-Act-Assert** pattern consistently followed
- **One assertion concept per test** (multiple assertions OK if testing same concept)
- **Test isolation** - no shared state between tests, proper cleanup guaranteed
- **Meaningful assertions** - avoid `toBeTruthy()`, use specific matchers
- **Test data factories** - use utilities from `test/helpers/test-utils.ts`

### 2.4 Test Infrastructure
- **GitTestEnvironment** required for all Git-related integration tests
- **TestResourceTracker** automatically cleans up branches, worktrees, temp directories
- **No manual cleanup in tests** - rely on infrastructure
- **Parallel test execution safe** - tests must not interfere with each other

## 3. User Experience Consistency

### 3.1 CLI Conventions
- **Commander.js** for all CLI argument parsing
- **Consistent flag naming**: kebab-case (e.g., `--auto-detect`, `--target-dir`)
- **Boolean flags** without required values (e.g., `--verbose`, not `--verbose=true`)
- **Variadic options** for lists (e.g., `--fallback <provider...>`)
- **Helpful defaults** - sensible behavior without configuration

### 3.2 User Feedback
- **Chalk colors** for semantic meaning:
  - Green (`chalk.green`) for success messages
  - Yellow (`chalk.yellow`) for warnings
  - Red (`chalk.red`) for errors
  - Cyan (`chalk.cyan`) for informational messages
  - Gray (`chalk.gray`) for secondary/debug info
- **Emoji indicators** for visual scanning:
  - ‚úÖ Success completion
  - ‚ö†Ô∏è Warnings that need attention
  - ‚ùå Errors that block progress
  - üìã Lists or summaries
  - üîÑ In-progress operations
- **Progressive disclosure** - show minimal output by default, verbose with `--verbose`
- **Actionable errors** - tell users what went wrong AND how to fix it

### 3.3 Configuration
- **Convention over configuration** - work out of the box with zero config
- **Zod validation** for all config files with helpful error messages
- **Config discovery** - search for `.commitmentrc`, `package.json`, etc.
- **Environment variable support** - `COMMITMENT_*` prefix for all env vars
- **Config merging** - CLI flags > env vars > config files > defaults

### 3.4 Output Consistency
- **Consistent formatting** across all commands
- **Machine-readable output** available with `--json` flag (future)
- **Exit codes**: 0 for success, non-zero for errors
- **Stderr for errors**, stdout for results

## 4. Performance Requirements

### 4.1 Startup Performance
- **CLI startup** must be < 500ms for cached builds
- **Lazy loading** for heavy dependencies (only load when needed)
- **Minimal dependencies** - evaluate bundle impact before adding
- **ESM-only builds** for faster startup and smaller bundles

### 4.2 Runtime Performance
- **Parallel operations** where possible (provider checks, Git operations)
- **Streaming output** for long-running operations (commit generation)
- **Caching** for expensive operations (provider availability checks)
- **Batch operations** to reduce syscall overhead

### 4.3 Build Performance
- **Incremental TypeScript builds** enabled
- **tsup for bundling** - faster than tsc + rollup
- **Development watch mode** for rapid iteration
- **Build time** < 5s for incremental, < 15s for clean builds

### 4.4 Test Performance
- **Unit tests** should run in < 5s total
- **All tests** should complete in < 30s
- **Parallel test execution** enabled by default
- **Test isolation** ensures no performance degradation over time

## 5. Provider System Architecture

### 5.1 Provider Interface Contract
- **AIProvider interface** is the single source of truth
- **All providers** must implement: `generateCommitMessage()`, `isAvailable()`, `getName()`, `getProviderType()`
- **Availability checks** must be fast (< 1s) and cached where appropriate
- **Error handling** must use domain-specific error classes

### 5.2 Provider Discovery
- **Auto-detection** tries providers in priority order
- **Provider chains** support fallback behavior
- **Configuration** supports both single providers and chains
- **Factory pattern** for provider instantiation with compile-time exhaustiveness checks

### 5.3 Provider Types
Two categories with distinct patterns:

1. **CLI Providers** (Claude, Codex, Cursor):
   - Extend `BaseCLIProvider`
   - Execute external commands via execa
   - Parse stdout/stderr for results
   - Validate command availability in `isAvailable()`

2. **API Providers** (OpenAI, Gemini):
   - Extend `BaseAPIProvider`
   - Make HTTP requests
   - Handle rate limiting and retries
   - Validate API keys in `isAvailable()`

## 6. Documentation Standards

### 6.1 Code Documentation
- **TSDoc comments** for all public APIs
- **Examples in docs** for non-trivial usage
- **@throws tags** for documented error cases
- **@deprecated tags** with migration instructions

### 6.2 Project Documentation
- **README.md** for high-level overview and quick start
- **CLAUDE.md** for AI assistant guidance and architecture
- **Constitution** (this file) for non-negotiable principles
- **CHANGELOG.md** for version history and migrations

### 6.3 Architecture Documentation
- **Decision records** for significant architectural choices
- **Diagrams** for complex flows (use ASCII art or mermaid)
- **Examples** showing typical usage patterns
- **Migration guides** for breaking changes

## 7. Git and Version Control

### 7.1 git-spice Workflow (MANDATORY)
All branch and commit operations MUST use [git-spice](https://abhinav.github.io/git-spice/) for stacked branch workflows. Direct `git` commands for branching and committing are **prohibited** in feature development.

**Required Commands**:
- **Branch creation**: `gs branch create <name>` (alias: `gs bc`) - NEVER use `git checkout -b`
- **Branch amendments**: `gs branch amend` - NEVER use `git commit --amend` directly
- **Restacking**: `gs stack restack` or `gs upstack restack` after any changes to lower branches
- **PR submission**: `gs stack submit` for submitting entire stacks
- **Branch tracking**: `gs branch track` for existing branches

**Prohibited Commands** (during feature development):
- ‚ùå `git checkout -b` - Use `gs branch create` instead
- ‚ùå `git commit --amend` - Use `gs branch amend` instead
- ‚ùå `git rebase` (manual) - Use `gs stack restack` instead
- ‚ùå Creating commits without stacking context

**Allowed git Commands**:
- ‚úÖ `git add` for staging changes
- ‚úÖ `git status` for checking status
- ‚úÖ `git diff` for reviewing changes
- ‚úÖ `git log` for viewing history
- ‚úÖ `git checkout <branch>` for switching branches (but prefer `gs branch checkout`)

**Stacked Workflow Pattern**:
```bash
# 1. Create first feature branch
gs branch create snu-123-add-feature-x

# 2. Make changes and commit (using commitment itself)
git add .
./dist/cli.js

# 3. Create second feature stacked on first
gs branch create snu-124-add-feature-y

# 4. Make changes and commit
git add .
./dist/cli.js

# 5. If you need to modify the first branch:
git checkout snu-123-add-feature-x
git add .
gs branch amend
gs stack restack  # Automatically rebases snu-124 on top

# 6. Submit entire stack as PRs
gs stack submit
```

### 7.2 Commit Standards
- **Conventional commits** format: `type(scope): description`
- **Types**: feat, fix, docs, style, refactor, test, chore
- **Scopes**: provider, cli, generator, config, test, build
- **Breaking changes** marked with `BREAKING CHANGE:` in body
- **AI co-authorship** credited: `Co-Authored-By: Claude <noreply@anthropic.com>`
- **Commit generation**: Use commitment itself (`./dist/cli.js`) for all commits

### 7.3 Branch Strategy
- **Main branch**: production-ready code only
- **Stacked branches**: All feature work done in stacks using git-spice
- **Branch naming**: `snu-<issue>-<description>` or `<type>/<description>`
- **Linear history** enforced via git-spice restacking
- **One logical change per branch** - keep branches focused and small
- **Clean PRs**: Each branch becomes one PR, reviewable independently but tested as a stack

### 7.4 Branch Management Rules
- **Never force-push** to shared branches without team coordination
- **Always restack** after modifying lower branches in a stack
- **Squash commits** within a branch before submission if needed (`gs branch squash`)
- **Track external branches** with `gs branch track` when collaborating
- **Delete branches** after merge - git-spice handles cleanup automatically

### 7.5 Release Process
- **Semantic versioning** strictly followed
- **Changelog generated** from conventional commits
- **Tests must pass** on main at all times
- **Build artifacts committed** for npm distribution
- **Release branches** may use standard git (not subject to git-spice requirement)

## 8. Dependency Management

### 8.1 Dependency Selection Criteria
- **Actively maintained** - recent commits, responsive maintainers
- **Well-typed** - includes TypeScript definitions
- **Minimal sub-dependencies** - avoid dependency bloat
- **ESM support** - must work with modern module system
- **Security** - no known vulnerabilities, regular updates

### 8.2 Specific Dependencies
**Required**:
- `zod` for runtime validation
- `ts-pattern` for pattern matching
- `execa` for subprocess execution
- `chalk` for terminal colors
- `commander` for CLI parsing

**Preferred**:
- `vitest` over Jest (faster, better ESM support)
- `tsup` over webpack/rollup (simpler, faster)
- Pure functions over class-based libraries

**Prohibited**:
- `lodash` (use native ES methods)
- `moment` (use native Date or date-fns)
- Any library with 100+ dependencies

### 8.3 pnpm Strictness
- **pnpm only** - no npm or yarn
- **Lockfile committed** - pnpm-lock.yaml must be up to date
- **Hoisting disabled** - strict dependency isolation
- **Peer dependencies** must be explicitly installed

## 9. Security Standards

### 9.1 Input Validation
- **All user input validated** with Zod schemas
- **Shell commands sanitized** - never use string interpolation
- **File paths normalized** - prevent directory traversal
- **Config files validated** - reject invalid configurations

### 9.2 Secrets Management
- **No secrets in code** - never commit API keys, tokens, etc.
- **Environment variables** for sensitive configuration
- **Prompts for interactive input** when secrets needed
- **.gitignore coverage** for common secret file patterns

### 9.3 External Execution
- **Subprocess sandboxing** - use execa with proper options
- **Timeout enforcement** - all external calls have timeouts
- **Error message sanitization** - don't leak sensitive info in errors
- **Git operations** - use simple-git with validation

## 10. Evolution and Change

### 10.1 Constitution Amendments
- **Constitution changes** require explicit discussion and consensus
- **Breaking principle changes** marked with version bump
- **Rationale documented** for all major changes
- **Migration path provided** when principles change

### 10.2 Technical Debt
- **TODO comments** must reference issue numbers
- **FIXME comments** require deadline or removal
- **Deprecated code** must have removal timeline
- **Legacy code** refactored incrementally, not rewritten

### 10.3 Continuous Improvement
- **Retrospectives** after major features
- **Metrics tracking**: build time, test time, bundle size
- **Performance budgets** enforced in CI
- **Dependency updates** reviewed monthly

---

**Version**: 1.0.0
**Last Updated**: 2025-10-08
**Status**: Active

These principles are living guidelines that evolve with the project while maintaining core values of quality, consistency, and user experience.
